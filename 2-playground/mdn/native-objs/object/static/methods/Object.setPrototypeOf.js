/* Object.setPrototypeOf(obj, prototype) */

//  - 설명:
//   - 지정된 객체의 프로토타입을 변경함. 이 메서드를 사용하여 객체의 프로토타입 체인을 동적으로 수정할 수 있음. 객체의 프로토타입을 동적으로 변경하는 기능. ES6에 도입됨
//   - 객체의 프로토타입을 동적으로 변경하는 데 사용되지만, 일반적으로 성능 저하를 초래할 수 있으므로 신중하게 사용해야 함. 객체 지향 프로그래밍에서 프로토타입을 관리하는 데 유용할 수 있음

//  - 활용:
//   - 지정된 객체의 프로토타입을 변경할 때 사용함

//  - 주의 사항:
//   - 프로토타입을 설정하는 것은 성능에 영향을 미칠 수 있으므로, 빈번하게 호출하는 것은 피하는 것이 좋음

//   - 성능 저하: 이 메서드는 프로토타입 체인을 동적으로 변경하므로, 성능에 부정적인 영향을 미칠 수 있음. JS 엔진은 프로토타입 체인을 최적화하기 어려워질 수 있음
//   - 비표준 프로토타입: 객체의 프로토타입을 변경하면, 기존의 프로토타입 메서드나 속성의 사용이 예기치 않게 동작할 수 있음. 따라서 객체의 원래 구조를 이해하고 사용해야 함
//   - Immutable Prototype: ES5의 Object.freeze()와 같은 메서드로 프로토타입이 동결된 경우, Object.setPrototypeOf()를 사용하여 프로토타입을 변경할 수 없음
//   - 사용 지양: 이 메서드는 프로토타입 상속을 설정하는 데 사용될 수 있지만, 코드의 가독성을 떨어뜨릴 수 있으며, 유지보수성이 저하될 수 있음. 일반적으로 클래스를 사용하거나 Object.create()를 통해 프로토타입을 설정하는 것이 더 권장됨
//   - 설정 가능성: 객체의 __proto__ 프로퍼티를 통해 직접 접근하는 것은 비표준 방식이며, Object.setPrototypeOf()를 사용하지 않는 것이 좋음

//   - 사용하지 않는 것을 권장하는 주요 요점:
//      - 성능 문제: 객체의 [[Prototype]]을 변경하는 것은 현대 JS 엔진이 프로퍼티 접근을 최적화하는 방식에 부정적인 영향을 줄 수 있음. 이로 인해 모든 이후의 프로퍼티 접근이 느려질 수 있음
//      - 부작용: 프로토타입을 변경하는 것이 코드의 다른 부분에도 영향을 미칠 수 있음. 즉, 객체의 프로토타입을 변경한 후의 모든 코드에서 그 변화가 영향을 줄 수 있음.
//      - 대안 제시: 성능이 우려된다면, Object.setPrototypeOf() 대신 Object.create()를 사용하여 새로운 객체를 생성하는 방법이 더 효율적이라는 권장 사항을 제시함. 이렇게 하면 프로토타입을 변경하는 데 따른 성능 저하를 피할 수 있음.

// 1. 사용 예
const proto = {
  greet() {
    return 'hi'
  },
}
const obj = {}

Object.setPrototypeOf(obj, proto)
console.log(obj.__proto__) // {greet: [Function: greet]}
console.log(obj.greet()) // hi

// 2. 프로토타입 체인 확인
const parent = { a: 1 }
const child = {}

console.log(child.__proto__) // [Object: null prototype] {}
Object.setPrototypeOf(child, parent) // 프로토타입 변경됨
console.log(child.__proto__) // { a: 1 }
