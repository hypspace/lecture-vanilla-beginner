/* Arrow Function */

// - 설명:
//  - 기존의 함수 표현식을 좀 더 간결하고 빠르게 타이핑하기 위한 표준적인 문법이 추가됨. 화살표 함수는 자신만의 this를 가지지 않고, 외부 컨텍스트에서 this를 그대로(상속받아) 사용함. 쉽게 말하면 화살표 함수에서의 this는 해당 함수가 어디서부터 정의되었는지를 가리킴
//  - 화살표 함수는 JS 함수 표현식의 한 형태로써 간결한 문법과 this 바인딩 특성 때문에 특히 콜백 함수로 많이 사용됨. 이는 화살표 함수에서 this 컨텍스트는 함수 선언문과는 다르게 this를 외부 컨텍스트에서 가져오는 점이 큰 특징.
//  - 어디에 선언되었는지를 가리키는데 함수가 정의된 위치(렉시컬 스코프)에 따라 결정됨. 자신의 this를 상위 스코프에서 가져오고 화살표 함수가 선언된 컨텍스트의 this를 그대로 사용함. 재차 화살표 함수가 정의된 위치의 상위 스코프에서 this를 상속받고 자신의 실행 컨텍스트가 아니라 외부 컨텍스트를 상속받아 가리킴

// - 화살표 함수와 일반 함수 표현식에서의 this:
//  - 화살표 함수: 자신이(화살표 함수) 어디서(어느 객체에서) 정의되었는지. this를 상위 스코프에서 가져오고 화살표 함수가 선언된 컨텍스트의 this를 그대로 사용함
//  - 일반 함수 표현식: 함수가 어디서부터(어느 객체로부터) 호출되었는지. 여기서 this는 호출 시점의 컨텍스트에 따라 결정됨

// 1. 여러가지 함수 표현식

// - 익명 함수 표현식: 가장 일반적인 형태
const add = function (a, b) {
  return a + b
}

// - 이름있는 함수 표현식: 함수에 이름을 지정하여 함수를 재귀적으로 호출할 때 사용함
const factorial = function fact(n) {
  if (n === 0) {
    return 1
  }
  return n * fact(n - 1)
}
console.log(factorial(5)) // 120 (5 * 4 * 3 * 2 * 1)을 의미함
console.log(factorial(6)) // 720 (6 * 5 * 4 * 3 * 2 * 1)을 의미함

// - 즉시-실행 함수 표현식: IIFE. 함수를 정의하자마자 바로 실행하는 형태임. 주로 스코프를 제한하거나 초기화를 위해 사용됨
;(function () {
  console.log('This is an IIFE') // "This is an IIFE"
})()

// 2. 화살표 함수에서의 this와 일반 함수 표현식에서의 this content의 동작에 대한 차이점
function Person() {
  // - 일반 함수
  setTimeout(function () {
    console.log(this) // "Timeout {...}" 호출부를 가리킴
  }, 1000)
  // - 화살표 함수
  setTimeout(() => {
    console.log(this) // "Person { age: 0 }" 외부의 선언부 객체를 가리킴. Person 생성자 함수로부터 선언되었기 때문에 Person 객체를 가리킴
  }, 1000)
}
new Person()
